// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.1
// source: jasper.proto

package internal

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	JasperProcessManager_ID_FullMethodName                         = "/jasper.JasperProcessManager/ID"
	JasperProcessManager_Create_FullMethodName                     = "/jasper.JasperProcessManager/Create"
	JasperProcessManager_List_FullMethodName                       = "/jasper.JasperProcessManager/List"
	JasperProcessManager_Group_FullMethodName                      = "/jasper.JasperProcessManager/Group"
	JasperProcessManager_Get_FullMethodName                        = "/jasper.JasperProcessManager/Get"
	JasperProcessManager_Signal_FullMethodName                     = "/jasper.JasperProcessManager/Signal"
	JasperProcessManager_Clear_FullMethodName                      = "/jasper.JasperProcessManager/Clear"
	JasperProcessManager_Close_FullMethodName                      = "/jasper.JasperProcessManager/Close"
	JasperProcessManager_TagProcess_FullMethodName                 = "/jasper.JasperProcessManager/TagProcess"
	JasperProcessManager_ResetTags_FullMethodName                  = "/jasper.JasperProcessManager/ResetTags"
	JasperProcessManager_GetTags_FullMethodName                    = "/jasper.JasperProcessManager/GetTags"
	JasperProcessManager_RegisterSignalTriggerID_FullMethodName    = "/jasper.JasperProcessManager/RegisterSignalTriggerID"
	JasperProcessManager_Wait_FullMethodName                       = "/jasper.JasperProcessManager/Wait"
	JasperProcessManager_Respawn_FullMethodName                    = "/jasper.JasperProcessManager/Respawn"
	JasperProcessManager_ScriptingHarnessCreate_FullMethodName     = "/jasper.JasperProcessManager/ScriptingHarnessCreate"
	JasperProcessManager_ScriptingHarnessCheck_FullMethodName      = "/jasper.JasperProcessManager/ScriptingHarnessCheck"
	JasperProcessManager_ScriptingHarnessSetup_FullMethodName      = "/jasper.JasperProcessManager/ScriptingHarnessSetup"
	JasperProcessManager_ScriptingHarnessCleanup_FullMethodName    = "/jasper.JasperProcessManager/ScriptingHarnessCleanup"
	JasperProcessManager_ScriptingHarnessRun_FullMethodName        = "/jasper.JasperProcessManager/ScriptingHarnessRun"
	JasperProcessManager_ScriptingHarnessBuild_FullMethodName      = "/jasper.JasperProcessManager/ScriptingHarnessBuild"
	JasperProcessManager_ScriptingHarnessRunScript_FullMethodName  = "/jasper.JasperProcessManager/ScriptingHarnessRunScript"
	JasperProcessManager_ScriptingHarnessTest_FullMethodName       = "/jasper.JasperProcessManager/ScriptingHarnessTest"
	JasperProcessManager_LoggingCacheCreate_FullMethodName         = "/jasper.JasperProcessManager/LoggingCacheCreate"
	JasperProcessManager_LoggingCacheGet_FullMethodName            = "/jasper.JasperProcessManager/LoggingCacheGet"
	JasperProcessManager_LoggingCacheRemove_FullMethodName         = "/jasper.JasperProcessManager/LoggingCacheRemove"
	JasperProcessManager_LoggingCacheCloseAndRemove_FullMethodName = "/jasper.JasperProcessManager/LoggingCacheCloseAndRemove"
	JasperProcessManager_LoggingCacheClear_FullMethodName          = "/jasper.JasperProcessManager/LoggingCacheClear"
	JasperProcessManager_LoggingCacheLen_FullMethodName            = "/jasper.JasperProcessManager/LoggingCacheLen"
	JasperProcessManager_LoggingCachePrune_FullMethodName          = "/jasper.JasperProcessManager/LoggingCachePrune"
	JasperProcessManager_Status_FullMethodName                     = "/jasper.JasperProcessManager/Status"
	JasperProcessManager_DownloadFile_FullMethodName               = "/jasper.JasperProcessManager/DownloadFile"
	JasperProcessManager_GetLogStream_FullMethodName               = "/jasper.JasperProcessManager/GetLogStream"
	JasperProcessManager_SignalEvent_FullMethodName                = "/jasper.JasperProcessManager/SignalEvent"
	JasperProcessManager_WriteFile_FullMethodName                  = "/jasper.JasperProcessManager/WriteFile"
	JasperProcessManager_SendMessages_FullMethodName               = "/jasper.JasperProcessManager/SendMessages"
)

// JasperProcessManagerClient is the client API for JasperProcessManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type JasperProcessManagerClient interface {
	// Manager functions
	ID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IDResponse, error)
	Create(ctx context.Context, in *CreateOptions, opts ...grpc.CallOption) (*ProcessInfo, error)
	List(ctx context.Context, in *Filter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProcessInfo], error)
	Group(ctx context.Context, in *TagName, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProcessInfo], error)
	Get(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessInfo, error)
	Signal(ctx context.Context, in *SignalProcess, opts ...grpc.CallOption) (*OperationOutcome, error)
	Clear(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error)
	Close(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error)
	// Process functions
	TagProcess(ctx context.Context, in *ProcessTags, opts ...grpc.CallOption) (*OperationOutcome, error)
	ResetTags(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*OperationOutcome, error)
	GetTags(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessTags, error)
	RegisterSignalTriggerID(ctx context.Context, in *SignalTriggerParams, opts ...grpc.CallOption) (*OperationOutcome, error)
	Wait(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*OperationOutcome, error)
	Respawn(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessInfo, error)
	// ScriptingHarness functions
	ScriptingHarnessCreate(ctx context.Context, in *ScriptingOptions, opts ...grpc.CallOption) (*ScriptingHarnessID, error)
	ScriptingHarnessCheck(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error)
	ScriptingHarnessSetup(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error)
	ScriptingHarnessCleanup(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error)
	ScriptingHarnessRun(ctx context.Context, in *ScriptingHarnessRunArgs, opts ...grpc.CallOption) (*OperationOutcome, error)
	ScriptingHarnessBuild(ctx context.Context, in *ScriptingHarnessBuildArgs, opts ...grpc.CallOption) (*ScriptingHarnessBuildResponse, error)
	ScriptingHarnessRunScript(ctx context.Context, in *ScriptingHarnessRunScriptArgs, opts ...grpc.CallOption) (*OperationOutcome, error)
	ScriptingHarnessTest(ctx context.Context, in *ScriptingHarnessTestArgs, opts ...grpc.CallOption) (*ScriptingHarnessTestResponse, error)
	// Logging functions
	LoggingCacheCreate(ctx context.Context, in *LoggingCacheCreateArgs, opts ...grpc.CallOption) (*LoggingCacheInstance, error)
	LoggingCacheGet(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*LoggingCacheInstance, error)
	LoggingCacheRemove(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*OperationOutcome, error)
	LoggingCacheCloseAndRemove(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*OperationOutcome, error)
	LoggingCacheClear(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error)
	LoggingCacheLen(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*LoggingCacheSize, error)
	LoggingCachePrune(ctx context.Context, in *timestamppb.Timestamp, opts ...grpc.CallOption) (*OperationOutcome, error)
	// Remote specific functions
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	DownloadFile(ctx context.Context, in *DownloadInfo, opts ...grpc.CallOption) (*OperationOutcome, error)
	GetLogStream(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogStream, error)
	SignalEvent(ctx context.Context, in *EventName, opts ...grpc.CallOption) (*OperationOutcome, error)
	WriteFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteFileInfo, OperationOutcome], error)
	SendMessages(ctx context.Context, in *LoggingPayload, opts ...grpc.CallOption) (*OperationOutcome, error)
}

type jasperProcessManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewJasperProcessManagerClient(cc grpc.ClientConnInterface) JasperProcessManagerClient {
	return &jasperProcessManagerClient{cc}
}

func (c *jasperProcessManagerClient) ID(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IDResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IDResponse)
	err := c.cc.Invoke(ctx, JasperProcessManager_ID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Create(ctx context.Context, in *CreateOptions, opts ...grpc.CallOption) (*ProcessInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessInfo)
	err := c.cc.Invoke(ctx, JasperProcessManager_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) List(ctx context.Context, in *Filter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProcessInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JasperProcessManager_ServiceDesc.Streams[0], JasperProcessManager_List_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Filter, ProcessInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_ListClient = grpc.ServerStreamingClient[ProcessInfo]

func (c *jasperProcessManagerClient) Group(ctx context.Context, in *TagName, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ProcessInfo], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JasperProcessManager_ServiceDesc.Streams[1], JasperProcessManager_Group_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TagName, ProcessInfo]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_GroupClient = grpc.ServerStreamingClient[ProcessInfo]

func (c *jasperProcessManagerClient) Get(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessInfo)
	err := c.cc.Invoke(ctx, JasperProcessManager_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Signal(ctx context.Context, in *SignalProcess, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_Signal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Clear(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Close(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_Close_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) TagProcess(ctx context.Context, in *ProcessTags, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_TagProcess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ResetTags(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ResetTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) GetTags(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessTags, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessTags)
	err := c.cc.Invoke(ctx, JasperProcessManager_GetTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) RegisterSignalTriggerID(ctx context.Context, in *SignalTriggerParams, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_RegisterSignalTriggerID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Wait(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_Wait_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Respawn(ctx context.Context, in *JasperProcessID, opts ...grpc.CallOption) (*ProcessInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessInfo)
	err := c.cc.Invoke(ctx, JasperProcessManager_Respawn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessCreate(ctx context.Context, in *ScriptingOptions, opts ...grpc.CallOption) (*ScriptingHarnessID, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScriptingHarnessID)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessCheck(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessSetup(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessSetup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessCleanup(ctx context.Context, in *ScriptingHarnessID, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessCleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessRun(ctx context.Context, in *ScriptingHarnessRunArgs, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessBuild(ctx context.Context, in *ScriptingHarnessBuildArgs, opts ...grpc.CallOption) (*ScriptingHarnessBuildResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScriptingHarnessBuildResponse)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessBuild_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessRunScript(ctx context.Context, in *ScriptingHarnessRunScriptArgs, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessRunScript_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) ScriptingHarnessTest(ctx context.Context, in *ScriptingHarnessTestArgs, opts ...grpc.CallOption) (*ScriptingHarnessTestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScriptingHarnessTestResponse)
	err := c.cc.Invoke(ctx, JasperProcessManager_ScriptingHarnessTest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheCreate(ctx context.Context, in *LoggingCacheCreateArgs, opts ...grpc.CallOption) (*LoggingCacheInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoggingCacheInstance)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheCreate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheGet(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*LoggingCacheInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoggingCacheInstance)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheRemove(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheCloseAndRemove(ctx context.Context, in *LoggingCacheArgs, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheCloseAndRemove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheClear(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheClear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCacheLen(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*LoggingCacheSize, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoggingCacheSize)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCacheLen_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) LoggingCachePrune(ctx context.Context, in *timestamppb.Timestamp, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_LoggingCachePrune_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, JasperProcessManager_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) DownloadFile(ctx context.Context, in *DownloadInfo, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_DownloadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) GetLogStream(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogStream, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogStream)
	err := c.cc.Invoke(ctx, JasperProcessManager_GetLogStream_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) SignalEvent(ctx context.Context, in *EventName, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_SignalEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jasperProcessManagerClient) WriteFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteFileInfo, OperationOutcome], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &JasperProcessManager_ServiceDesc.Streams[2], JasperProcessManager_WriteFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WriteFileInfo, OperationOutcome]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_WriteFileClient = grpc.ClientStreamingClient[WriteFileInfo, OperationOutcome]

func (c *jasperProcessManagerClient) SendMessages(ctx context.Context, in *LoggingPayload, opts ...grpc.CallOption) (*OperationOutcome, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OperationOutcome)
	err := c.cc.Invoke(ctx, JasperProcessManager_SendMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JasperProcessManagerServer is the server API for JasperProcessManager service.
// All implementations must embed UnimplementedJasperProcessManagerServer
// for forward compatibility.
type JasperProcessManagerServer interface {
	// Manager functions
	ID(context.Context, *emptypb.Empty) (*IDResponse, error)
	Create(context.Context, *CreateOptions) (*ProcessInfo, error)
	List(*Filter, grpc.ServerStreamingServer[ProcessInfo]) error
	Group(*TagName, grpc.ServerStreamingServer[ProcessInfo]) error
	Get(context.Context, *JasperProcessID) (*ProcessInfo, error)
	Signal(context.Context, *SignalProcess) (*OperationOutcome, error)
	Clear(context.Context, *emptypb.Empty) (*OperationOutcome, error)
	Close(context.Context, *emptypb.Empty) (*OperationOutcome, error)
	// Process functions
	TagProcess(context.Context, *ProcessTags) (*OperationOutcome, error)
	ResetTags(context.Context, *JasperProcessID) (*OperationOutcome, error)
	GetTags(context.Context, *JasperProcessID) (*ProcessTags, error)
	RegisterSignalTriggerID(context.Context, *SignalTriggerParams) (*OperationOutcome, error)
	Wait(context.Context, *JasperProcessID) (*OperationOutcome, error)
	Respawn(context.Context, *JasperProcessID) (*ProcessInfo, error)
	// ScriptingHarness functions
	ScriptingHarnessCreate(context.Context, *ScriptingOptions) (*ScriptingHarnessID, error)
	ScriptingHarnessCheck(context.Context, *ScriptingHarnessID) (*OperationOutcome, error)
	ScriptingHarnessSetup(context.Context, *ScriptingHarnessID) (*OperationOutcome, error)
	ScriptingHarnessCleanup(context.Context, *ScriptingHarnessID) (*OperationOutcome, error)
	ScriptingHarnessRun(context.Context, *ScriptingHarnessRunArgs) (*OperationOutcome, error)
	ScriptingHarnessBuild(context.Context, *ScriptingHarnessBuildArgs) (*ScriptingHarnessBuildResponse, error)
	ScriptingHarnessRunScript(context.Context, *ScriptingHarnessRunScriptArgs) (*OperationOutcome, error)
	ScriptingHarnessTest(context.Context, *ScriptingHarnessTestArgs) (*ScriptingHarnessTestResponse, error)
	// Logging functions
	LoggingCacheCreate(context.Context, *LoggingCacheCreateArgs) (*LoggingCacheInstance, error)
	LoggingCacheGet(context.Context, *LoggingCacheArgs) (*LoggingCacheInstance, error)
	LoggingCacheRemove(context.Context, *LoggingCacheArgs) (*OperationOutcome, error)
	LoggingCacheCloseAndRemove(context.Context, *LoggingCacheArgs) (*OperationOutcome, error)
	LoggingCacheClear(context.Context, *emptypb.Empty) (*OperationOutcome, error)
	LoggingCacheLen(context.Context, *emptypb.Empty) (*LoggingCacheSize, error)
	LoggingCachePrune(context.Context, *timestamppb.Timestamp) (*OperationOutcome, error)
	// Remote specific functions
	Status(context.Context, *emptypb.Empty) (*StatusResponse, error)
	DownloadFile(context.Context, *DownloadInfo) (*OperationOutcome, error)
	GetLogStream(context.Context, *LogRequest) (*LogStream, error)
	SignalEvent(context.Context, *EventName) (*OperationOutcome, error)
	WriteFile(grpc.ClientStreamingServer[WriteFileInfo, OperationOutcome]) error
	SendMessages(context.Context, *LoggingPayload) (*OperationOutcome, error)
	mustEmbedUnimplementedJasperProcessManagerServer()
}

// UnimplementedJasperProcessManagerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedJasperProcessManagerServer struct{}

func (UnimplementedJasperProcessManagerServer) ID(context.Context, *emptypb.Empty) (*IDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ID not implemented")
}
func (UnimplementedJasperProcessManagerServer) Create(context.Context, *CreateOptions) (*ProcessInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedJasperProcessManagerServer) List(*Filter, grpc.ServerStreamingServer[ProcessInfo]) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedJasperProcessManagerServer) Group(*TagName, grpc.ServerStreamingServer[ProcessInfo]) error {
	return status.Errorf(codes.Unimplemented, "method Group not implemented")
}
func (UnimplementedJasperProcessManagerServer) Get(context.Context, *JasperProcessID) (*ProcessInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedJasperProcessManagerServer) Signal(context.Context, *SignalProcess) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Signal not implemented")
}
func (UnimplementedJasperProcessManagerServer) Clear(context.Context, *emptypb.Empty) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedJasperProcessManagerServer) Close(context.Context, *emptypb.Empty) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Close not implemented")
}
func (UnimplementedJasperProcessManagerServer) TagProcess(context.Context, *ProcessTags) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagProcess not implemented")
}
func (UnimplementedJasperProcessManagerServer) ResetTags(context.Context, *JasperProcessID) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetTags not implemented")
}
func (UnimplementedJasperProcessManagerServer) GetTags(context.Context, *JasperProcessID) (*ProcessTags, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTags not implemented")
}
func (UnimplementedJasperProcessManagerServer) RegisterSignalTriggerID(context.Context, *SignalTriggerParams) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSignalTriggerID not implemented")
}
func (UnimplementedJasperProcessManagerServer) Wait(context.Context, *JasperProcessID) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}
func (UnimplementedJasperProcessManagerServer) Respawn(context.Context, *JasperProcessID) (*ProcessInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Respawn not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessCreate(context.Context, *ScriptingOptions) (*ScriptingHarnessID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessCreate not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessCheck(context.Context, *ScriptingHarnessID) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessCheck not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessSetup(context.Context, *ScriptingHarnessID) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessSetup not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessCleanup(context.Context, *ScriptingHarnessID) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessCleanup not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessRun(context.Context, *ScriptingHarnessRunArgs) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessRun not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessBuild(context.Context, *ScriptingHarnessBuildArgs) (*ScriptingHarnessBuildResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessBuild not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessRunScript(context.Context, *ScriptingHarnessRunScriptArgs) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessRunScript not implemented")
}
func (UnimplementedJasperProcessManagerServer) ScriptingHarnessTest(context.Context, *ScriptingHarnessTestArgs) (*ScriptingHarnessTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScriptingHarnessTest not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheCreate(context.Context, *LoggingCacheCreateArgs) (*LoggingCacheInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheCreate not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheGet(context.Context, *LoggingCacheArgs) (*LoggingCacheInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheGet not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheRemove(context.Context, *LoggingCacheArgs) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheRemove not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheCloseAndRemove(context.Context, *LoggingCacheArgs) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheCloseAndRemove not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheClear(context.Context, *emptypb.Empty) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheClear not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCacheLen(context.Context, *emptypb.Empty) (*LoggingCacheSize, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCacheLen not implemented")
}
func (UnimplementedJasperProcessManagerServer) LoggingCachePrune(context.Context, *timestamppb.Timestamp) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoggingCachePrune not implemented")
}
func (UnimplementedJasperProcessManagerServer) Status(context.Context, *emptypb.Empty) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedJasperProcessManagerServer) DownloadFile(context.Context, *DownloadInfo) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedJasperProcessManagerServer) GetLogStream(context.Context, *LogRequest) (*LogStream, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogStream not implemented")
}
func (UnimplementedJasperProcessManagerServer) SignalEvent(context.Context, *EventName) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignalEvent not implemented")
}
func (UnimplementedJasperProcessManagerServer) WriteFile(grpc.ClientStreamingServer[WriteFileInfo, OperationOutcome]) error {
	return status.Errorf(codes.Unimplemented, "method WriteFile not implemented")
}
func (UnimplementedJasperProcessManagerServer) SendMessages(context.Context, *LoggingPayload) (*OperationOutcome, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessages not implemented")
}
func (UnimplementedJasperProcessManagerServer) mustEmbedUnimplementedJasperProcessManagerServer() {}
func (UnimplementedJasperProcessManagerServer) testEmbeddedByValue()                              {}

// UnsafeJasperProcessManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to JasperProcessManagerServer will
// result in compilation errors.
type UnsafeJasperProcessManagerServer interface {
	mustEmbedUnimplementedJasperProcessManagerServer()
}

func RegisterJasperProcessManagerServer(s grpc.ServiceRegistrar, srv JasperProcessManagerServer) {
	// If the following call pancis, it indicates UnimplementedJasperProcessManagerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&JasperProcessManager_ServiceDesc, srv)
}

func _JasperProcessManager_ID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ID(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Create(ctx, req.(*CreateOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JasperProcessManagerServer).List(m, &grpc.GenericServerStream[Filter, ProcessInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_ListServer = grpc.ServerStreamingServer[ProcessInfo]

func _JasperProcessManager_Group_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TagName)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(JasperProcessManagerServer).Group(m, &grpc.GenericServerStream[TagName, ProcessInfo]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_GroupServer = grpc.ServerStreamingServer[ProcessInfo]

func _JasperProcessManager_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JasperProcessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Get(ctx, req.(*JasperProcessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Signal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalProcess)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Signal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Signal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Signal(ctx, req.(*SignalProcess))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Clear(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Close_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Close(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Close_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Close(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_TagProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessTags)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).TagProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_TagProcess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).TagProcess(ctx, req.(*ProcessTags))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ResetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JasperProcessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ResetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ResetTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ResetTags(ctx, req.(*JasperProcessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_GetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JasperProcessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).GetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_GetTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).GetTags(ctx, req.(*JasperProcessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_RegisterSignalTriggerID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignalTriggerParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).RegisterSignalTriggerID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_RegisterSignalTriggerID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).RegisterSignalTriggerID(ctx, req.(*SignalTriggerParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JasperProcessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Wait_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Wait(ctx, req.(*JasperProcessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Respawn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JasperProcessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Respawn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Respawn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Respawn(ctx, req.(*JasperProcessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCreate(ctx, req.(*ScriptingOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCheck(ctx, req.(*ScriptingHarnessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessSetup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessSetup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessSetup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessSetup(ctx, req.(*ScriptingHarnessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessCleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessCleanup(ctx, req.(*ScriptingHarnessID))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessRunArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessRun(ctx, req.(*ScriptingHarnessRunArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessBuildArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessBuild_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessBuild(ctx, req.(*ScriptingHarnessBuildArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessRunScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessRunScriptArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessRunScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessRunScript_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessRunScript(ctx, req.(*ScriptingHarnessRunScriptArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_ScriptingHarnessTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScriptingHarnessTestArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).ScriptingHarnessTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_ScriptingHarnessTest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).ScriptingHarnessTest(ctx, req.(*ScriptingHarnessTestArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggingCacheCreateArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheCreate(ctx, req.(*LoggingCacheCreateArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggingCacheArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheGet(ctx, req.(*LoggingCacheArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggingCacheArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheRemove(ctx, req.(*LoggingCacheArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheCloseAndRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggingCacheArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheCloseAndRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheCloseAndRemove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheCloseAndRemove(ctx, req.(*LoggingCacheArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheClear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheClear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheClear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheClear(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCacheLen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCacheLen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCacheLen_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCacheLen(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_LoggingCachePrune_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(timestamppb.Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).LoggingCachePrune(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_LoggingCachePrune_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).LoggingCachePrune(ctx, req.(*timestamppb.Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_DownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).DownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_DownloadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).DownloadFile(ctx, req.(*DownloadInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_GetLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).GetLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_GetLogStream_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).GetLogStream(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_SignalEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).SignalEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_SignalEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).SignalEvent(ctx, req.(*EventName))
	}
	return interceptor(ctx, in, info, handler)
}

func _JasperProcessManager_WriteFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(JasperProcessManagerServer).WriteFile(&grpc.GenericServerStream[WriteFileInfo, OperationOutcome]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type JasperProcessManager_WriteFileServer = grpc.ClientStreamingServer[WriteFileInfo, OperationOutcome]

func _JasperProcessManager_SendMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoggingPayload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JasperProcessManagerServer).SendMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: JasperProcessManager_SendMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JasperProcessManagerServer).SendMessages(ctx, req.(*LoggingPayload))
	}
	return interceptor(ctx, in, info, handler)
}

// JasperProcessManager_ServiceDesc is the grpc.ServiceDesc for JasperProcessManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var JasperProcessManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jasper.JasperProcessManager",
	HandlerType: (*JasperProcessManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ID",
			Handler:    _JasperProcessManager_ID_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _JasperProcessManager_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _JasperProcessManager_Get_Handler,
		},
		{
			MethodName: "Signal",
			Handler:    _JasperProcessManager_Signal_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _JasperProcessManager_Clear_Handler,
		},
		{
			MethodName: "Close",
			Handler:    _JasperProcessManager_Close_Handler,
		},
		{
			MethodName: "TagProcess",
			Handler:    _JasperProcessManager_TagProcess_Handler,
		},
		{
			MethodName: "ResetTags",
			Handler:    _JasperProcessManager_ResetTags_Handler,
		},
		{
			MethodName: "GetTags",
			Handler:    _JasperProcessManager_GetTags_Handler,
		},
		{
			MethodName: "RegisterSignalTriggerID",
			Handler:    _JasperProcessManager_RegisterSignalTriggerID_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _JasperProcessManager_Wait_Handler,
		},
		{
			MethodName: "Respawn",
			Handler:    _JasperProcessManager_Respawn_Handler,
		},
		{
			MethodName: "ScriptingHarnessCreate",
			Handler:    _JasperProcessManager_ScriptingHarnessCreate_Handler,
		},
		{
			MethodName: "ScriptingHarnessCheck",
			Handler:    _JasperProcessManager_ScriptingHarnessCheck_Handler,
		},
		{
			MethodName: "ScriptingHarnessSetup",
			Handler:    _JasperProcessManager_ScriptingHarnessSetup_Handler,
		},
		{
			MethodName: "ScriptingHarnessCleanup",
			Handler:    _JasperProcessManager_ScriptingHarnessCleanup_Handler,
		},
		{
			MethodName: "ScriptingHarnessRun",
			Handler:    _JasperProcessManager_ScriptingHarnessRun_Handler,
		},
		{
			MethodName: "ScriptingHarnessBuild",
			Handler:    _JasperProcessManager_ScriptingHarnessBuild_Handler,
		},
		{
			MethodName: "ScriptingHarnessRunScript",
			Handler:    _JasperProcessManager_ScriptingHarnessRunScript_Handler,
		},
		{
			MethodName: "ScriptingHarnessTest",
			Handler:    _JasperProcessManager_ScriptingHarnessTest_Handler,
		},
		{
			MethodName: "LoggingCacheCreate",
			Handler:    _JasperProcessManager_LoggingCacheCreate_Handler,
		},
		{
			MethodName: "LoggingCacheGet",
			Handler:    _JasperProcessManager_LoggingCacheGet_Handler,
		},
		{
			MethodName: "LoggingCacheRemove",
			Handler:    _JasperProcessManager_LoggingCacheRemove_Handler,
		},
		{
			MethodName: "LoggingCacheCloseAndRemove",
			Handler:    _JasperProcessManager_LoggingCacheCloseAndRemove_Handler,
		},
		{
			MethodName: "LoggingCacheClear",
			Handler:    _JasperProcessManager_LoggingCacheClear_Handler,
		},
		{
			MethodName: "LoggingCacheLen",
			Handler:    _JasperProcessManager_LoggingCacheLen_Handler,
		},
		{
			MethodName: "LoggingCachePrune",
			Handler:    _JasperProcessManager_LoggingCachePrune_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _JasperProcessManager_Status_Handler,
		},
		{
			MethodName: "DownloadFile",
			Handler:    _JasperProcessManager_DownloadFile_Handler,
		},
		{
			MethodName: "GetLogStream",
			Handler:    _JasperProcessManager_GetLogStream_Handler,
		},
		{
			MethodName: "SignalEvent",
			Handler:    _JasperProcessManager_SignalEvent_Handler,
		},
		{
			MethodName: "SendMessages",
			Handler:    _JasperProcessManager_SendMessages_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _JasperProcessManager_List_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Group",
			Handler:       _JasperProcessManager_Group_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteFile",
			Handler:       _JasperProcessManager_WriteFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "jasper.proto",
}
